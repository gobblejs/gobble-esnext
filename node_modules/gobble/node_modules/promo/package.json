{
  "name": "promo",
  "description": "Convert node-style callback-based functions into promise-based equivalents for easier composition",
  "version": "0.1.1",
  "author": {
    "name": "Rich Harris"
  },
  "dependencies": {
    "es6-promise": "^1.0.0"
  },
  "keywords": [
    "promise"
  ],
  "readme": "# promo.js\n\nConvert node-style callback-based functions into promise-based equivalents for easier composition.\n\n\n## Installation\n\n```\n$ npm i promo\n```\n\n\n## Usage\n\n```js\nvar promo = require( 'promo' );\n\n// Take a standard function...\nvar standard = function ( arg1, arg2, arg3, callback ) {\n  // callback is eventually called with two arguments - an error\n  // (if applicable) and the result;\n};\n\n// ...and create a promise-returning equivalent\nvar promisified = promo( standard );\n\n// Then, instead of doing this...\nstandard( a, b, c, function ( err, result ) {\n\tif ( err ) {\n\t\treturn handleError( err );\n\t}\n\n\thandleResult( result );\n});\n\n// ...do this:\npromisified( a, b, c ).then( handleResult, handleError );\n```\n\nReal-world example:\n\n```js\nvar readFile = promo( require( 'fs' ).readFile ),\n    writeFile = promo( require( 'fs' ).writeFile ),\n    glob = promo( require( 'glob' ) ),\n    mkdirp = promo( require( 'mkdirp' ) );\n```\n\nIf necessary, you can pass in the context as a second argument:\n\n```js\nvar someModule = {\n  someMethod: function ( callback ) {\n    // because this method uses `this`, we need to\n    // pass in a context\n    this.doSomething( callback );\n  }\n};\n\nvar promisified = promo( someModule.someMethod, someModule );\n```\n\nIf you convert a function that references `this`, and don't pass in a context, promo will warn you about it.\n\n\n## Credits\n\nThis module uses [es6-promise](https://github.com/jakearchibald/es6-promise) by Jake Archibald.\n\n\n## License\n\nMIT.\n",
  "readmeFilename": "README.md",
  "_id": "promo@0.1.1",
  "_from": "promo@~0.1.1"
}
